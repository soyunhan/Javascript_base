//지뢰 탐지가 필요해
// 😃 설명) windows에서 지원하는 지뢰 찾기 게임을 한번쯤은 해 보았을 것이다. 
// 특히 르탄이는 지뢰찾기의 매니아로 알려져 있다. 지뢰 찾기 map은 N*N의 정사각형 모양으로
// 각 칸에는 숫자가 들어가 있거나 지뢰가 들어가 있다. 빈 칸에는 숫자 0이 들어있다고 생각하자.

// map의 어떤 칸에 적혀 있는 숫자는, 그 칸과 인접해 있는 여덟 개의 칸 중에서 지뢰가 들어 있는
// 칸이 몇 개인지를 나타내 준다. 물론 인접한 칸이 map 내부에 있는 경우에 대해서만 생각하면 된다.
// 예제를 보면 더 잘 이해할 수 있을 것이다.

// 이번 문제는 조금 업그레이드 된 지뢰 찾기로, 한 칸에 한 개의 지뢰가 있는 것이 아니고,
// 한 칸에 여러 개(1 이상 9 이하)의 지뢰가 묻혀 있는 게임이다. 따라서 map의 어떤 칸에 적혀 있는 숫자는,
// 그 칸과 인접해 있는 여덟 개의 칸들에 들어 있는 지뢰의 총 개수가 된다.

// 이미 windows 지뢰찾기 같은 것을 마스터한 르탄이는, map에서 지뢰에 대한 정보만이 주어졌을 때,
// 르탄이는 map을 완성하고 싶다고 한다. N과 지뢰의 위치가 주어졌을 때,
// 르탄이를 도와서 지뢰 찾기 map을 완성하는 프로그램을 작성하시오.

// (단, 1 ≤ N ≤ 1,000 이며, 배열의 각 요소에는 지뢰 찾기 map에 대한 정보가 주어지는데 '.' 또는
// 숫자로 이루어진 문자열이 들어온다. '.'는 지뢰가 없는 것이고 숫자는 지뢰가 있는 경우로 그 칸의 지뢰의 개수이다.
// 한 줄은 N개의 문자로 이루어져 있다.


// let N = 4; 
// let chars= {{'2', '.', '.', '.',},        
//  {'.', '.', '9', '.'},        
//  {'.', '3', '.', '2'},        
//  {'.', '4', '.', '.'}};	
 
// // [[*, M, 9, 9],
// //  [5, M, *, M],
// //  [7, *, M, *],
// //  [7, *, 9, 2]]
// N을 입력받음
let N = 4;

// 입력받은 지뢰찾기 map을 li 리스트에 저장
let li = ['2...',
'.9..',
'.3.2',
'.4..'];

li.unshift('.'.repeat(N+2));
li.push('.'.repeat(N+2));

// 결과를 저장할 res 리스트 초기화
let res = [];

// 각각의 칸을 검사하면서 주변 지뢰 수를 구하고, 결과 리스트에 저장
for (let i = 1; i <= N; i++) {
let s = '';
for (let j = 1; j <= N; j++) {
// 현재 칸이 지뢰이면 * 추가
if (li[i][j] >= '0' && li[i][j] <= '9') {
s += '*';
}
// 현재 칸이 지뢰가 아니면 주변 8칸의 지뢰 수를 구해서 추가
else {
let bomb = 0;
for (let a = i-1; a <= i+1; a++) {
for (let b = j-1; b <= j+1; b++) {
if (li[a][b] >= '0' && li[a][b] <= '9') {
bomb += parseInt(li[a][b]);
}
}
}
s += bomb < 10 ? bomb.toString() : 'M';
}
}
res.push(s);
}

// 결과 리스트 출력
for (let s of res) {
console.log(s);
}

